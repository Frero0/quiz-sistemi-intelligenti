[
  {
    "question": "Quale dei seguenti meccanismi non serve per indurre regole di classificazione?",
    "options": [
      "K nearest neighbour",
      "Specific to general",
      "General to specific"
    ],
    "answer": "K nearest neighbour",
    "explanation": "KNN è un classificatore basato sulla memoria e distanza, non genera regole simboliche esplicite."
  },
  {
    "question": "Associazione concetti nell'ontologia musicale",
    "type": "matching",
    "pairs": {
      "timpano member percussione": "c. relazione di istanza",
      "haPlettro(Y) => cordofono(Y)": "d. proprietà di classe",
      "timpano isa percussione": "a. relazione di sottoclasse",
      "{archi, legni, percussioni}": "b. insieme disgiunto",
      "ottone part-of orchestra": "e. una categoria è componente di un’altra"
    }
  },
  {
    "question": "Valutazione formula logica A: not P1(x) or P2(x) or not P3(x), B: P(ID0)",
    "type": "truefalse",
    "statements": {
      "La formula A) è una clausola": true,
      "Il forward chaining è applicabile": false,
      "La formula A) è una clausola di Horn": true,
      "La risoluzione è applicabile": true,
      "Il modus ponens è applicabile": false
    }
  },
  {
    "question": "Associa i seguenti meccanismi logici ai tipi di ragionamento che supportano",
    "type": "matching",
    "pairs": {
      "model checking": "d. conseguenza logica",
      "modus ponens generalizzato": "e. forward chaining FOL",
      "proposizionalizzazione": "c. traduzione di una KB FOL in logica proposizionale",
      "modus ponens": "b. forward chaining CSP",
      "binary resolution/risoluzione": "a. ragionamento per refutazione in FOL"
    },
    "explanation": "Ogni meccanismo supporta un diverso tipo di inferenza: la risoluzione opera per refutazione, il model checking verifica la conseguenza logica, mentre i due modus ponens differiscono per il tipo di logica (proposizionale o FOL)."
  },
  {
    "question": "Associa correttamente gli algoritmi elencati ai compiti che svolgono",
    "type": "matching",
    "pairs": {
      "foward checking": "e. ricerca di una soluzione per un CSP",
      "test-and-set": "d. nessuna di queste",
      "general-to-specific": "a. apprendimento regole",
      "foward chaining": "c. inferenza da una KB in clausole di Horn",
      "ricerca bidirezionale": "b. ricerca di una soluzione in uno spazio degli stati"
    },
    "explanation": "Ogni algoritmo è pensato per un contesto specifico: forward checking per CSP, chaining per inferenza logica, general-to-specific per apprendere regole. Test-and-set è legato alla concorrenza, non all'intelligenza artificiale."
  },
  {
    "question": "Associa correttamente gli algoritmi elencati ai compiti che svolgono",
    "type": "matching",
    "pairs": {
      "algoritmo di Hunt": "c. costruzione di alberi di decisione",
      "K-NN": "d. classificazione senza un modello",
      "back-jumping": "a. risoluzione in CSP",
      "RBFS": "g. ricerca di una soluzione in uno spazio degli stati",
      "specie-to-general": "f. apprendimento di regole",
      "alpha-beta-pruning": "e. riduzione dello spazio di ricerca in un gioco con avversario",
      "minimax": "b. suggerimento della prossima mossa in un problema con avversario"
    },
    "explanation": "Questi algoritmi coprono vari ambiti: CSP, apprendimento supervisionato, giochi, e ricerca. Ad esempio, minimax e alpha-beta sono per giochi a due giocatori, mentre K-NN è un classificatore lazy."
  },
  {
    "question": "Associa correttamente gli algoritmi elencati ai compiti che svolgono",
    "type": "matching",
    "pairs": {
      "K-NN": "c. apprendimento supervisionato",
      "back-jumping": "a. trova una soluzione per il CSP",
      "ricerca bidirezionale": "e. trova una soluzione in uno spazio degli stati",
      "risoluzione": "d. verifica se una formula è derivabile da una KB",
      "backward chaining": "b. verifica se un goal è derivabile da una KB e certi fatti"
    },
    "explanation": "Gli algoritmi si distinguono per tipo di problema: risoluzione e chaining per inferenza logica, K-NN per classificazione supervisionata, back-jumping e ricerca per CSP e spazi degli stati."
  },
  {
    "question": "Effettua le combinazioni corrette tra euristiche e i loro ruoli",
    "type": "matching",
    "pairs": {
      "un’euristica dominante": "d. approssima meglio h*(n)",
      "un’euristica ammissibile": "c. è ottimistica",
      "l’euristica minimum remaining values": "e. garantisce l'ottimalità nella ricerca su grafo",
      "l’euristica di grado": "b. identifica una variabile coinvolta in molti vincoli",
      "Un’euristica monotona": "a. facilita il fallimento precoce"
    },
    "explanation": "Le euristiche guidano la ricerca: le ammissibili non sovrastimano, quelle dominanti sono migliori, mentre le CSP euristiche aiutano nella selezione delle variabili."
  },
  {
    "question": "Associazione concetti nell'ontologia degli autoveicoli",
    "type": "matching",
    "pairs": {
      "CT456XY is a automobile": "d. relazione errata",
      "CT456XY member automobile": "e. relazione di istanza",
      "member(X, automobile) => velocitàMax(50)": "b. proprietà di classe",
      "carrozzeria part-of automobile": "a. una categoria è componente di un'altra",
      "{mezziDaLavoro, mezziPersonali}": "c. decomposizione esaustiva rispetto a veicolo"
    },
    "explanation": "L’ontologia distingue tra istanza, composizione e proprietà: 'member' indica appartenenza, 'part-of' una componente, le partizioni rappresentano suddivisioni esaustive."
  },
  {
    "question": "Associazione concetti nell'ontologia astronomica",
    "type": "matching",
    "pairs": {
      "Mercurio member pianeta": "d. relazione di istanza",
      "member(X, pianeta) => sferoidale": "c. proprietà di classe",
      "astrometria isa astronomia": "a. relazione di sottoclasse",
      "{solare, extrasolare, interstellare} rispetto a pianeta": "b. partizione",
      "magnetosfera part-of pianeta": "e. relazione di composizione"
    },
    "explanation": "L'ontologia rappresenta relazioni tra entità: 'isa' per sottoclassi, 'member' per istanze, 'part-of' per composizione fisica, e le partizioni per categorizzazioni esclusive."
  },
  {
    "question": "Associazione concetti nell'ontologia musicale",
    "type": "matching",
    "pairs": {
      "timpano member percussione": "c. relazione di istanza",
      "haPlettro(Y) => cordofono(Y)": "d. proprietà di classe",
      "timpano isa percussione": "a. relazione di sottoclasse",
      "{archi, legni, percussioni}": "b. insieme disgiunto",
      "ottone part-of orchestra": "e. una categoria è componente di un’altra"
    },
    "explanation": "La tassonomia musicale include istanze (member), sottoclassi (isa), proprietà (implicazioni), disgiunzioni e relazioni di composizione tra strumenti e gruppi."
  },
  {
    "question": "Valutazione formula logica A: not P1(x) or P2(x) or not P3(x), B: P(ID0)",
    "type": "truefalse",
    "statements": {
      "La formula A) è una clausola": true,
      "Il forward chaining è applicabile": false,
      "La formula A) è una clausola di Horn": true,
      "La risoluzione è applicabile": true,
      "Il modus ponens è applicabile": false
    },
    "explanation": "Una clausola di Horn ha al massimo un letterale positivo, quindi A lo è. La risoluzione si applica, ma non il modus ponens se la forma non è implicativa."
  },
  {
    "question": "Formula FOL: A) Cane(Asso), B) Custode(Proprietario(x,x)), C) Cane(x) ∧ Custode(y,x) → Responsabile(y)",
    "type": "truefalse",
    "statements": {
      "Il modus ponens generalizzato non è applicabile": false,
      "Sostituzione: x/Asso, z/z, y/Proprietario(Asso)": false,
      "Risultato: Cane(Asso) ∧ Custode(y,Asso)": false,
      "Risultato: Responsabile(Proprietario(Asso))": true,
      "Sostituzione: x/Asso, z/Asso, y/Proprietario(Asso)": true
    },
    "explanation": "Il modus ponens generalizzato può essere applicato dopo unificazione tra la premessa e i fatti; le sostituzioni corrette permettono di dedurre Responsabile(Proprietario(Asso))."
  },
  {
    "question": "Regola di risoluzione con A) not Ottone(x) or Percussione(x) or not Arco(x), B) Ottone(ID0)",
    "type": "truefalse",
    "statements": {
      "L’unificatore è {z/ID0}": true,
      "La risoluzione non è applicabile": false,
      "Risolvente: Ottone(ID0)": false,
      "Risolvente: Percussione(ID0) or not Arco(ID0)": true,
      "Risolvente: Percussione(x) or not Arco(x)": false
    },
    "explanation": "Applicando la risoluzione tra la clausola A e il fatto Ottone(ID0), si elimina 'not Ottone(x)' e si ottiene una nuova clausola con le restanti disgiunzioni istanziate."
  },
  {
    "question": "Tre formule: A) Alfa(ID1) or not Beta(x) or Gamma(x), B) Alfa(ID0), C) Beta(ID1)",
    "type": "truefalse",
    "statements": {
      "La formula A) è una clausola di Horn": false,
      "Il forward chaining è applicabile": false,
      "La formula A) è una clausola": true,
      "Si può derivare Gamma(ID1)": false,
      "Il modus ponens generalizzato è applicabile": false
    },
    "explanation": "A non è una clausola di Horn perché contiene più di un letterale positivo. Inoltre, le premesse non permettono di applicare forward chaining né modus ponens generalizzato."
  },
  {
    "question": "Formule con A) not Alfa(x) or Beta(x) or not Gamma(x), B) Alfa(ID0), C) Gamma(ID0)",
    "type": "truefalse",
    "statements": {
      "La formula A) è una clausola di Horn": true,
      "Il forward chaining è applicabile": true,
      "La formula A) è una clausola": true,
      "La risoluzione è applicabile": true,
      "Il modus ponens generalizzato è applicabile": true
    },
    "explanation": "In questo caso, la clausola A è una clausola di Horn e le formule B e C possono essere usate per applicare forward chaining, risoluzione e modus ponens generalizzato."
  }
]